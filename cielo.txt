-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Cielo API v3 Bindings for Haskell
--   
--   Cielo API v3 Bindings
@package cielo
@version 0.1.2.0

module Web.Payments.Cielo.Types.DeriveJSON
deriveJSON :: Name -> Q [Dec]
uncapitalize :: String -> String

module Web.Payments.Cielo.Types
type MonadCielo m = (MonadIO m, MonadReader CieloConfig m, MonadError CieloError m)
type CieloM a = ReaderT CieloConfig (ExceptT CieloError IO) a
data CieloConfig
CieloConfig :: Merchant -> Environment -> CieloConfig
[cieloConfigMerchant] :: CieloConfig -> Merchant
[cieloConfigEnvironment] :: CieloConfig -> Environment
data CieloError
CieloJSONError :: String -> SomeException -> ByteString -> CieloError
CieloInvalidError :: String -> HttpException -> (Maybe Value) -> CieloError
CieloNotFoundError :: String -> HttpException -> CieloError
CieloHttpException :: String -> HttpException -> (Maybe Value) -> CieloError
data Merchant
Merchant :: Text -> Text -> Merchant
[merchantId] :: Merchant -> Text
[merchantKey] :: Merchant -> Text
data Environment
Environment :: Text -> Text -> Environment
[environmentApiUrl] :: Environment -> Text
[environmentApiQueryUrl] :: Environment -> Text
productionEnv :: Environment
sandboxEnv :: Environment
data PaymentProvider
PaymentProviderBradesco :: PaymentProvider
PaymentProviderBancoDoBrasil :: PaymentProvider
PaymentProviderSimulado :: PaymentProvider
data PaymentType
PaymentTypeCreditCard :: PaymentType
PaymentTypeDebitCard :: PaymentType
PaymentTypeElectronicTransfer :: PaymentType
PaymentTypeBoleto :: PaymentType
data Currency
CurrencyBRL :: Currency
CurrencyUSD :: Currency
CurrencyMXN :: Currency
CurrencyCOP :: Currency
CurrencyCLP :: Currency
CurrencyARS :: Currency
CurrencyPEN :: Currency
CurrencyEUR :: Currency
CurrencyPYN :: Currency
CurrencyUYU :: Currency
CurrencyVEB :: Currency
CurrencyVEF :: Currency
CurrencyGBP :: Currency
data Interval
IntervalMonthly :: Interval
IntervalBimonthly :: Interval
IntervalQuarterly :: Interval
IntervalSemiAnnual :: Interval
IntervalAnnual :: Interval
data RecurrentPayment
RecurrentPayment :: Maybe Bool -> Maybe Text -> Maybe Text -> Maybe Interval -> Maybe Text -> RecurrentPayment
[recurrentPaymentAuthorizeNow] :: RecurrentPayment -> Maybe Bool
[recurrentPaymentEndDate] :: RecurrentPayment -> Maybe Text
[recurrentPaymentStartDate] :: RecurrentPayment -> Maybe Text
[recurrentPaymentInterval] :: RecurrentPayment -> Maybe Interval
[recurrentPaymentRecurrentPaymentId] :: RecurrentPayment -> Maybe Text
data Address
Address :: Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Address
[addressStreet] :: Address -> Maybe Text
[addressNumber] :: Address -> Maybe Text
[addressComplement] :: Address -> Maybe Text
[addressZipCode] :: Address -> Maybe Text
[addressCity] :: Address -> Maybe Text
[addressState] :: Address -> Maybe Text
[addressCountry] :: Address -> Maybe Text
data CreditCard
CreditCard :: Text -> Text -> Text -> Maybe Text -> Maybe Bool -> Text -> Maybe Text -> CreditCard
[creditCardCardNumber] :: CreditCard -> Text
[creditCardHolder] :: CreditCard -> Text
[creditCardExpirationDate] :: CreditCard -> Text
[creditCardSecurityCode] :: CreditCard -> Maybe Text
[creditCardSaveCard] :: CreditCard -> Maybe Bool
[creditCardBrand] :: CreditCard -> Text
[creditCardCardToken] :: CreditCard -> Maybe Text
data Customer
Customer :: Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Address -> Maybe Address -> Customer
[customerName] :: Customer -> Text
[customerEmail] :: Customer -> Maybe Text
[customerBirthDate] :: Customer -> Maybe Text
[customerIdentity] :: Customer -> Maybe Text
[customerIdentityType] :: Customer -> Maybe Text
[customerAddress] :: Customer -> Maybe Address
[customerDeliveryAddress] :: Customer -> Maybe Address
data Payment
Payment :: Maybe Int -> Maybe Int -> Maybe Value -> Maybe CreditCard -> Maybe PaymentType -> Maybe Int -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe RecurrentPayment -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe PaymentProvider -> Maybe Text -> Maybe Text -> Maybe Int -> Maybe Text -> Maybe Currency -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Int -> Maybe [Value] -> Maybe [Value] -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Payment
[paymentServiceTaxAmount] :: Payment -> Maybe Int
[paymentInstallments] :: Payment -> Maybe Int

-- | Sometimes this is a string, sometimes it's an int... :P
[paymentInterest] :: Payment -> Maybe Value
[paymentCreditCard] :: Payment -> Maybe CreditCard
[paymentType] :: Payment -> Maybe PaymentType
[paymentAmount] :: Payment -> Maybe Int
[paymentCapture] :: Payment -> Maybe Bool
[paymentAuthenticate] :: Payment -> Maybe Bool
[paymentRecurrent] :: Payment -> Maybe Bool
[paymentRecurrentPayment] :: Payment -> Maybe RecurrentPayment
[paymentTid] :: Payment -> Maybe Text
[paymentProofOfSale] :: Payment -> Maybe Text
[paymentAuthorizationCode] :: Payment -> Maybe Text
[paymentSoftDescriptor] :: Payment -> Maybe Text
[paymentReturnUrl] :: Payment -> Maybe Text
[paymentProvider] :: Payment -> Maybe PaymentProvider
[paymentPaymentId] :: Payment -> Maybe Text
[paymentReceivedDate] :: Payment -> Maybe Text
[paymentCapturedAmount] :: Payment -> Maybe Int
[paymentCapturedDate] :: Payment -> Maybe Text
[paymentCurrency] :: Payment -> Maybe Currency
[paymentCountry] :: Payment -> Maybe Text
[paymentReturnCode] :: Payment -> Maybe Text
[paymentReturnMessage] :: Payment -> Maybe Text
[paymentStatus] :: Payment -> Maybe Int
[paymentLinks] :: Payment -> Maybe [Value]
[paymentExtraDataCollection] :: Payment -> Maybe [Value]
[paymentExpirationDate] :: Payment -> Maybe Text
[paymentUrl] :: Payment -> Maybe Text
[paymentNumber] :: Payment -> Maybe Text
[paymentBarCodeNumber] :: Payment -> Maybe Text
[paymentDigitableLine] :: Payment -> Maybe Text
[paymentAddress] :: Payment -> Maybe Text
data Sale
Sale :: Text -> Customer -> Payment -> Sale
[saleMerchantOrderId] :: Sale -> Text
[saleCustomer] :: Sale -> Customer
[salePayment] :: Sale -> Payment
data SaleUpdate
SaleUpdate :: Int -> Text -> Text -> [Value] -> SaleUpdate
[saleUpdateStatus] :: SaleUpdate -> Int
[saleUpdateReturnCode] :: SaleUpdate -> Text
[saleUpdateReturnMessage] :: SaleUpdate -> Text
[saleUpdateLinks] :: SaleUpdate -> [Value]
data RecurrentPaymentQuery
RecurrentPaymentQuery :: RecurrentPayment -> Customer -> RecurrentPaymentQuery
[recurrentPaymentQueryRecurrentPayment] :: RecurrentPaymentQuery -> RecurrentPayment
[recurrentPaymentQueryCustomer] :: RecurrentPaymentQuery -> Customer
data SalesByMerchantOrderQuery
SalesByMerchantOrderQuery :: [Payment] -> SalesByMerchantOrderQuery
[salesByMerchantOrderQueryPayments] :: SalesByMerchantOrderQuery -> [Payment]
instance Data.Aeson.Types.Class.ToJSON Web.Payments.Cielo.Types.SalesByMerchantOrderQuery
instance Data.Aeson.Types.Class.FromJSON Web.Payments.Cielo.Types.SalesByMerchantOrderQuery
instance GHC.Classes.Eq Web.Payments.Cielo.Types.SalesByMerchantOrderQuery
instance GHC.Show.Show Web.Payments.Cielo.Types.SalesByMerchantOrderQuery
instance GHC.Read.Read Web.Payments.Cielo.Types.SalesByMerchantOrderQuery
instance Data.Aeson.Types.Class.ToJSON Web.Payments.Cielo.Types.RecurrentPaymentQuery
instance Data.Aeson.Types.Class.FromJSON Web.Payments.Cielo.Types.RecurrentPaymentQuery
instance GHC.Classes.Eq Web.Payments.Cielo.Types.RecurrentPaymentQuery
instance GHC.Show.Show Web.Payments.Cielo.Types.RecurrentPaymentQuery
instance GHC.Read.Read Web.Payments.Cielo.Types.RecurrentPaymentQuery
instance Data.Aeson.Types.Class.ToJSON Web.Payments.Cielo.Types.SaleUpdate
instance Data.Aeson.Types.Class.FromJSON Web.Payments.Cielo.Types.SaleUpdate
instance GHC.Classes.Eq Web.Payments.Cielo.Types.SaleUpdate
instance GHC.Show.Show Web.Payments.Cielo.Types.SaleUpdate
instance GHC.Read.Read Web.Payments.Cielo.Types.SaleUpdate
instance Data.Aeson.Types.Class.ToJSON Web.Payments.Cielo.Types.Sale
instance Data.Aeson.Types.Class.FromJSON Web.Payments.Cielo.Types.Sale
instance GHC.Classes.Eq Web.Payments.Cielo.Types.Sale
instance GHC.Show.Show Web.Payments.Cielo.Types.Sale
instance GHC.Read.Read Web.Payments.Cielo.Types.Sale
instance Data.Aeson.Types.Class.ToJSON Web.Payments.Cielo.Types.Payment
instance Data.Aeson.Types.Class.FromJSON Web.Payments.Cielo.Types.Payment
instance GHC.Classes.Eq Web.Payments.Cielo.Types.Payment
instance GHC.Show.Show Web.Payments.Cielo.Types.Payment
instance GHC.Read.Read Web.Payments.Cielo.Types.Payment
instance Data.Aeson.Types.Class.ToJSON Web.Payments.Cielo.Types.Customer
instance Data.Aeson.Types.Class.FromJSON Web.Payments.Cielo.Types.Customer
instance Data.Default.Class.Default Web.Payments.Cielo.Types.Payment
instance GHC.Classes.Eq Web.Payments.Cielo.Types.Customer
instance GHC.Show.Show Web.Payments.Cielo.Types.Customer
instance GHC.Read.Read Web.Payments.Cielo.Types.Customer
instance Data.Aeson.Types.Class.ToJSON Web.Payments.Cielo.Types.CreditCard
instance Data.Aeson.Types.Class.FromJSON Web.Payments.Cielo.Types.CreditCard
instance Data.Default.Class.Default Web.Payments.Cielo.Types.Customer
instance GHC.Classes.Eq Web.Payments.Cielo.Types.CreditCard
instance GHC.Show.Show Web.Payments.Cielo.Types.CreditCard
instance GHC.Read.Read Web.Payments.Cielo.Types.CreditCard
instance Data.Aeson.Types.Class.ToJSON Web.Payments.Cielo.Types.Address
instance Data.Aeson.Types.Class.FromJSON Web.Payments.Cielo.Types.Address
instance Data.Default.Class.Default Web.Payments.Cielo.Types.CreditCard
instance GHC.Classes.Eq Web.Payments.Cielo.Types.Address
instance GHC.Show.Show Web.Payments.Cielo.Types.Address
instance GHC.Read.Read Web.Payments.Cielo.Types.Address
instance Data.Aeson.Types.Class.ToJSON Web.Payments.Cielo.Types.RecurrentPayment
instance Data.Aeson.Types.Class.FromJSON Web.Payments.Cielo.Types.RecurrentPayment
instance Data.Default.Class.Default Web.Payments.Cielo.Types.Address
instance GHC.Classes.Eq Web.Payments.Cielo.Types.RecurrentPayment
instance GHC.Show.Show Web.Payments.Cielo.Types.RecurrentPayment
instance GHC.Read.Read Web.Payments.Cielo.Types.RecurrentPayment
instance GHC.Classes.Eq Web.Payments.Cielo.Types.Interval
instance GHC.Show.Show Web.Payments.Cielo.Types.Interval
instance GHC.Read.Read Web.Payments.Cielo.Types.Interval
instance Data.Aeson.Types.Class.ToJSON Web.Payments.Cielo.Types.Currency
instance Data.Aeson.Types.Class.FromJSON Web.Payments.Cielo.Types.Currency
instance Data.Default.Class.Default Web.Payments.Cielo.Types.Interval
instance Data.Aeson.Types.Class.ToJSON Web.Payments.Cielo.Types.Interval
instance Data.Aeson.Types.Class.FromJSON Web.Payments.Cielo.Types.Interval
instance Data.Default.Class.Default Web.Payments.Cielo.Types.RecurrentPayment
instance GHC.Classes.Eq Web.Payments.Cielo.Types.Currency
instance GHC.Show.Show Web.Payments.Cielo.Types.Currency
instance GHC.Read.Read Web.Payments.Cielo.Types.Currency
instance Data.Aeson.Types.Class.ToJSON Web.Payments.Cielo.Types.PaymentType
instance Data.Aeson.Types.Class.FromJSON Web.Payments.Cielo.Types.PaymentType
instance Data.Default.Class.Default Web.Payments.Cielo.Types.Currency
instance GHC.Classes.Eq Web.Payments.Cielo.Types.PaymentType
instance GHC.Show.Show Web.Payments.Cielo.Types.PaymentType
instance GHC.Read.Read Web.Payments.Cielo.Types.PaymentType
instance Data.Aeson.Types.Class.ToJSON Web.Payments.Cielo.Types.PaymentProvider
instance Data.Aeson.Types.Class.FromJSON Web.Payments.Cielo.Types.PaymentProvider
instance Data.Default.Class.Default Web.Payments.Cielo.Types.PaymentType
instance GHC.Classes.Eq Web.Payments.Cielo.Types.PaymentProvider
instance GHC.Show.Show Web.Payments.Cielo.Types.PaymentProvider
instance GHC.Read.Read Web.Payments.Cielo.Types.PaymentProvider
instance GHC.Classes.Eq Web.Payments.Cielo.Types.Environment
instance GHC.Show.Show Web.Payments.Cielo.Types.Environment
instance GHC.Read.Read Web.Payments.Cielo.Types.Environment
instance GHC.Classes.Eq Web.Payments.Cielo.Types.Merchant
instance GHC.Show.Show Web.Payments.Cielo.Types.Merchant
instance GHC.Read.Read Web.Payments.Cielo.Types.Merchant
instance GHC.Show.Show Web.Payments.Cielo.Types.CieloError
instance GHC.Exception.Exception Web.Payments.Cielo.Types.CieloError
instance Data.Default.Class.Default Web.Payments.Cielo.Types.Environment

module Web.Payments.Cielo

-- | API Calls happen in a <a>MonadCielo</a> type-class <a>CieloM</a> is a
--   helper instance of this class, which runs exceptions on the IO monad
--   and exposes the configuration through a <a>ReaderT</a>
runCielo :: CieloConfig -> CieloM a -> IO a

-- | We can load <a>CieloConfig</a> from the
--   <tt><a>CIELO_MERCHANTID</a></tt> and <tt><a>CIELO_MERCHANTKEY</a></tt>
--   environment variables
cieloConfigFromEnv :: IO CieloConfig
productionEnv :: Environment
sandboxEnv :: Environment

-- | Generates a new merchant UIID
getMerchantOrderId :: MonadIO m => m Text

-- | Creates a <a>Sale</a>
createSale :: MonadCielo m => Sale -> m Sale

-- | Queries for a <a>Sale</a> given it's paymentId
querySale :: MonadCielo m => Text -> m Sale

-- | Captures a sale
captureSale :: MonadCielo m => Text -> Maybe Int -> Maybe Int -> m SaleUpdate

-- | Voids a sale
voidSale :: MonadCielo m => Text -> Maybe Int -> m SaleUpdate

-- | Updates a sale (Generalized PUT over a type of Sale update
--   <tt><i>1</i>sales<i>:id</i>:type</tt>)
updateSale :: MonadCielo m => Text -> Text -> [(Text, Text)] -> m SaleUpdate

-- | Queries for a sales given a merchant UUID
querySalesByMerchantOrderId :: MonadCielo m => Text -> m SalesByMerchantOrderQuery

-- | Queries for a recurrent sale given it's paymentId
queryRecurrentSale :: MonadCielo m => Text -> m RecurrentPaymentQuery
cancelRecurrentPayment :: MonadCielo m => Text -> m ()
uncancelRecurrentPayment :: MonadCielo m => Text -> m ()
updateRecurrentPaymentEndDate :: MonadCielo m => Text -> Text -> m ()
updateRecurrentPaymentPayment :: MonadCielo m => Text -> Payment -> m ()
updateRecurrentPaymentInterval :: MonadCielo m => Text -> Int -> m ()
updateRecurrentPaymentInstallments :: MonadCielo m => Text -> Int -> m ()
updateRecurrentPaymentCustomer :: MonadCielo m => Text -> Customer -> m ()
updateRecurrentPaymentRecurrencyDay :: MonadCielo m => Text -> Int -> m ()
updateRecurrentPaymentNextPaymentDate :: MonadCielo m => Text -> Text -> m ()
updateRecurrentPaymentNextPaymentAmount :: MonadCielo m => Text -> Int -> m ()
data CieloConfig
CieloConfig :: Merchant -> Environment -> CieloConfig
[cieloConfigMerchant] :: CieloConfig -> Merchant
[cieloConfigEnvironment] :: CieloConfig -> Environment
type MonadCielo m = (MonadIO m, MonadReader CieloConfig m, MonadError CieloError m)
data CieloError
CieloJSONError :: String -> SomeException -> ByteString -> CieloError
CieloInvalidError :: String -> HttpException -> (Maybe Value) -> CieloError
CieloNotFoundError :: String -> HttpException -> CieloError
CieloHttpException :: String -> HttpException -> (Maybe Value) -> CieloError
data Merchant
Merchant :: Text -> Text -> Merchant
[merchantId] :: Merchant -> Text
[merchantKey] :: Merchant -> Text
data Environment
Environment :: Text -> Text -> Environment
[environmentApiUrl] :: Environment -> Text
[environmentApiQueryUrl] :: Environment -> Text
data Sale
Sale :: Text -> Customer -> Payment -> Sale
[saleMerchantOrderId] :: Sale -> Text
[saleCustomer] :: Sale -> Customer
[salePayment] :: Sale -> Payment
data PaymentProvider
PaymentProviderBradesco :: PaymentProvider
PaymentProviderBancoDoBrasil :: PaymentProvider
PaymentProviderSimulado :: PaymentProvider
data PaymentType
PaymentTypeCreditCard :: PaymentType
PaymentTypeDebitCard :: PaymentType
PaymentTypeElectronicTransfer :: PaymentType
PaymentTypeBoleto :: PaymentType
data Currency
CurrencyBRL :: Currency
CurrencyUSD :: Currency
CurrencyMXN :: Currency
CurrencyCOP :: Currency
CurrencyCLP :: Currency
CurrencyARS :: Currency
CurrencyPEN :: Currency
CurrencyEUR :: Currency
CurrencyPYN :: Currency
CurrencyUYU :: Currency
CurrencyVEB :: Currency
CurrencyVEF :: Currency
CurrencyGBP :: Currency
data Interval
IntervalMonthly :: Interval
IntervalBimonthly :: Interval
IntervalQuarterly :: Interval
IntervalSemiAnnual :: Interval
IntervalAnnual :: Interval
data RecurrentPayment
RecurrentPayment :: Maybe Bool -> Maybe Text -> Maybe Text -> Maybe Interval -> Maybe Text -> RecurrentPayment
[recurrentPaymentAuthorizeNow] :: RecurrentPayment -> Maybe Bool
[recurrentPaymentEndDate] :: RecurrentPayment -> Maybe Text
[recurrentPaymentStartDate] :: RecurrentPayment -> Maybe Text
[recurrentPaymentInterval] :: RecurrentPayment -> Maybe Interval
[recurrentPaymentRecurrentPaymentId] :: RecurrentPayment -> Maybe Text
data RecurrentPaymentQuery
RecurrentPaymentQuery :: RecurrentPayment -> Customer -> RecurrentPaymentQuery
[recurrentPaymentQueryRecurrentPayment] :: RecurrentPaymentQuery -> RecurrentPayment
[recurrentPaymentQueryCustomer] :: RecurrentPaymentQuery -> Customer
data Address
Address :: Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Address
[addressStreet] :: Address -> Maybe Text
[addressNumber] :: Address -> Maybe Text
[addressComplement] :: Address -> Maybe Text
[addressZipCode] :: Address -> Maybe Text
[addressCity] :: Address -> Maybe Text
[addressState] :: Address -> Maybe Text
[addressCountry] :: Address -> Maybe Text
data Customer
Customer :: Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Address -> Maybe Address -> Customer
[customerName] :: Customer -> Text
[customerEmail] :: Customer -> Maybe Text
[customerBirthDate] :: Customer -> Maybe Text
[customerIdentity] :: Customer -> Maybe Text
[customerIdentityType] :: Customer -> Maybe Text
[customerAddress] :: Customer -> Maybe Address
[customerDeliveryAddress] :: Customer -> Maybe Address
data Payment
Payment :: Maybe Int -> Maybe Int -> Maybe Value -> Maybe CreditCard -> Maybe PaymentType -> Maybe Int -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe RecurrentPayment -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe PaymentProvider -> Maybe Text -> Maybe Text -> Maybe Int -> Maybe Text -> Maybe Currency -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Int -> Maybe [Value] -> Maybe [Value] -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Payment
[paymentServiceTaxAmount] :: Payment -> Maybe Int
[paymentInstallments] :: Payment -> Maybe Int

-- | Sometimes this is a string, sometimes it's an int... :P
[paymentInterest] :: Payment -> Maybe Value
[paymentCreditCard] :: Payment -> Maybe CreditCard
[paymentType] :: Payment -> Maybe PaymentType
[paymentAmount] :: Payment -> Maybe Int
[paymentCapture] :: Payment -> Maybe Bool
[paymentAuthenticate] :: Payment -> Maybe Bool
[paymentRecurrent] :: Payment -> Maybe Bool
[paymentRecurrentPayment] :: Payment -> Maybe RecurrentPayment
[paymentTid] :: Payment -> Maybe Text
[paymentProofOfSale] :: Payment -> Maybe Text
[paymentAuthorizationCode] :: Payment -> Maybe Text
[paymentSoftDescriptor] :: Payment -> Maybe Text
[paymentReturnUrl] :: Payment -> Maybe Text
[paymentProvider] :: Payment -> Maybe PaymentProvider
[paymentPaymentId] :: Payment -> Maybe Text
[paymentReceivedDate] :: Payment -> Maybe Text
[paymentCapturedAmount] :: Payment -> Maybe Int
[paymentCapturedDate] :: Payment -> Maybe Text
[paymentCurrency] :: Payment -> Maybe Currency
[paymentCountry] :: Payment -> Maybe Text
[paymentReturnCode] :: Payment -> Maybe Text
[paymentReturnMessage] :: Payment -> Maybe Text
[paymentStatus] :: Payment -> Maybe Int
[paymentLinks] :: Payment -> Maybe [Value]
[paymentExtraDataCollection] :: Payment -> Maybe [Value]
[paymentExpirationDate] :: Payment -> Maybe Text
[paymentUrl] :: Payment -> Maybe Text
[paymentNumber] :: Payment -> Maybe Text
[paymentBarCodeNumber] :: Payment -> Maybe Text
[paymentDigitableLine] :: Payment -> Maybe Text
[paymentAddress] :: Payment -> Maybe Text
data SalesByMerchantOrderQuery
SalesByMerchantOrderQuery :: [Payment] -> SalesByMerchantOrderQuery
[salesByMerchantOrderQueryPayments] :: SalesByMerchantOrderQuery -> [Payment]

-- | A class for types with a default value.
class Default a

-- | The default value for this type.
def :: a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: * -> *)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: IO a -> m a

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   In many cases, you can get the compiler to generate parsing code for
--   you (see below). To begin, let's cover writing an instance by hand.
--   
--   There are various reasons a conversion could fail. For example, an
--   <a>Object</a> could be missing a required key, an <a>Array</a> could
--   be of the wrong size, or a value could be of an incompatible type.
--   
--   The basic ways to signal a failed conversion are as follows:
--   
--   <ul>
--   <li><tt>empty</tt> and <tt>mzero</tt> work, but are terse and
--   uninformative</li>
--   <li><a>fail</a> yields a custom error message</li>
--   <li><a>typeMismatch</a> produces an informative message for cases when
--   the value encountered is not of the expected type</li>
--   </ul>
--   
--   An example type and instance:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where
--     parseJSON (<a>Object</a> v) = Coord    <a>&lt;$&gt;</a>
--                            v <tt>.:</tt> "x" <a>&lt;*&gt;</a>
--                            v <tt>.:</tt> "y"
--   
--     -- We do not expect a non-<a>Object</a> value here.
--     -- We could use <tt>mzero</tt> to fail, but <a>typeMismatch</a>
--     -- gives a much more informative error message.
--     parseJSON invalid    = <a>typeMismatch</a> "Coord" invalid
--   </pre>
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   two options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>parseJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>FromJSON</a> instance for
--   your datatype without giving a definition for <a>parseJSON</a>.
--   
--   For example, the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance FromJSON Coord
--   </pre>
--   
--   If <tt>DefaultSignatures</tt> doesn't give exactly the results you
--   want, you can customize the generic decoding with only a tiny amount
--   of effort, using <a>genericParseJSON</a> with your preferred
--   <a>Options</a>:
--   
--   <pre>
--   instance FromJSON Coord where
--       parseJSON = <a>genericParseJSON</a> <a>defaultOptions</a>
--   </pre>
class FromJSON a
parseJSON :: Value -> Parser a

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where
--     toJSON (Coord x y) = <a>object</a> ["x" <a>.=</a> x, "y" <a>.=</a> y]
--   
--     toEncoding (Coord x y) = <tt>pairs</tt> ("x" <a>.=</a> x <tt>&lt;&gt;</tt> "y" <a>.=</a> y)
--   </pre>
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are two
--   options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>toJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>ToJSON</a> instance for your
--   datatype without giving definitions for <a>toJSON</a> or
--   <a>toEncoding</a>.
--   
--   For example, the previous example can be simplified to a more minimal
--   instance:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance ToJSON Coord where
--       toEncoding = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
--   
--   Why do we provide an implementation for <a>toEncoding</a> here? The
--   <a>toEncoding</a> function is a relatively new addition to this class.
--   To allow users of older versions of this library to upgrade without
--   having to edit all of their instances or encounter surprising
--   incompatibilities, the default implementation of <a>toEncoding</a>
--   uses <a>toJSON</a>. This produces correct results, but since it
--   performs an intermediate conversion to a <a>Value</a>, it will be less
--   efficient than directly emitting an <a>Encoding</a>. Our one-liner
--   definition of <a>toEncoding</a> above bypasses the intermediate
--   <a>Value</a>.
--   
--   If <tt>DefaultSignatures</tt> doesn't give exactly the results you
--   want, you can customize the generic encoding with only a tiny amount
--   of effort, using <a>genericToJSON</a> and <a>genericToEncoding</a>
--   with your preferred <a>Options</a>:
--   
--   <pre>
--   instance ToJSON Coord where
--       toJSON     = <a>genericToJSON</a> <a>defaultOptions</a>
--       toEncoding = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
class ToJSON a

-- | Convert a Haskell value to a JSON-friendly intermediate type.
toJSON :: a -> Value

-- | Encode a Haskell value as JSON.
--   
--   The default implementation of this method creates an intermediate
--   <a>Value</a> using <a>toJSON</a>. This provides source-level
--   compatibility for people upgrading from older versions of this
--   library, but obviously offers no performance advantage.
--   
--   To benefit from direct encoding, you <i>must</i> provide an
--   implementation for this method. The easiest way to do so is by having
--   your types implement <a>Generic</a> using the <tt>DeriveGeneric</tt>
--   extension, and then have GHC generate a method body as follows.
--   
--   <pre>
--   instance ToJSON Coord where
--       toEncoding = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
toEncoding :: a -> Encoding
